---
layout:     post
title:      "JVM-GC原理"
subtitle:   " \"知识点\""
date:       2018-08-03 10:00:00
author:     "lang"
header-img: "http://lyang-blog-pics.oss-cn-shanghai.aliyuncs.com/post-bg-2017/0330/170330.jpg"

catalog: true
tags:
    - Tech
---

> Heap是GC管理的主要区域，是用于存放对象实例的地方

# 对象回收

判断对象是否存活有两种算法：**引用计数法** 和 **可达性分析方法**  

1. 引用计数法，给每一个对象添加引用计数器，每当有一个引用指向它时，计数器加一，计数器为0时，判断为可回收对象，这种方法很难解决 *对象循环引用问题*  
2. 可达性分析算法是Java正在使用的算法，基本思想是系统从 *GC Root* 对象为起点向下搜索，搜索走过的路径成为引用链，当一个对象不在任何引用链上，则判断为可回收对象  

GC Root包括一下几种对象

1. 虚拟栈中引用的对象
2. 本地方法栈中JNI引用的对象
3. 方法区中类静态成员变量引用的对象
4. 方法区中常量引用的对象  

**对象是否存活都与引用有关**，引用又分为强引用、软引用、弱引用、虚引用  

1. 强引用 Strong reference，只要强引用存在，被引用对象就不会被回收，如：  
    Object obj = new Object();
2. 软引用 soft reference，内存溢出之前进行回收，如下sf为obj的一个软引用：  
    Object obj = new Object();
    SoftReference<Object> sf = new SoftReference<Object>(obj)  
3. 弱引用 weak reference，第二次（下一次）垃圾回收时会被回收  
4. 虚引用 Phantom reference， 虚引用不对关联对象的生存时间构成影响，也无法取得对象实例，它唯一的作用就是在对象被GC回收时收到一条系统通知

# 垃圾回收算法

目前存在4中比较成熟的垃圾收集算法：**标记-清除算法、复制算法、标记整理算法、分代收集算法**  

1. 标记-清除算法，首先标记需要回收的对象，标记完成后回收所有被标记的对象。这种算法会产生大量不连续的内存碎片，当需要分配一个大对象时，jvm在新生代中找不到足够大的连续内存块，会导致jvm频繁的进行内存回收  
2. 复制算法，将内存分为相等的两个块，每次只使用其中一块，当这块内存不够用时，就将存活的对象复制到另外一块内存，然后把这块内存一次性清理，这样做效率比较高，也避免了内存碎片，但内存可使用空间减半  
3. 标记-整理算法，是标记-清除算法的升级版，完成标记后，不直接回收对象，而是让存活对象向着一端移动，然后清理掉边界以外的内存  
4. 分代收集算法，当前商业jvm都采用这种算法，根据对象存活周期将内存分为新生代和老年代，然后根据不同年代的特点，采用不同的收集算法。在新生代中，每次垃圾收集都有大量对象死去，只有少量存活，所以选择用复制算法，而老年代对象存活率比较高，所以采用标记-整理（或者标记-清除）算法  

# 对象分配

Minor GC，当新对象生成并在Eden申请空间失败，就会触发Minor GC  
Full GC， 对整个堆进行整理，速度比Minor GC慢，在对JVM调优的过程中很大一部分工作就是对Full GC的调节，**老年代被写满、持久代被写满、system.gc()被显示调用、上一次GC后Heap各区域分配策略动态变化**都会导致Full GC  

对象分配  

1. 优先在Eden区分配。jvm年轻代分为三个部分：1个Eden区和2个Survivor区（分别为from和to区），默认比例为8：1。一般情况下（大对象特殊处理），新建的对象都会被分配到Eden区，这些对象经过第一次Minor GC后，如果仍然存活，就会被移动到Survivor区，每熬过一次Minor GC，年龄就会增加1岁，当年龄增加到一定程度，就会被移动到老年代  
2. 当GC开始时，对象只会存在Eden区和名为from的Survivor区，紧接着进行GC，Eden会全部移动到to区，而from会根据年龄阈值决定是移动到老年代区还是to区。经过GC后Eden和from都被清空，这时，from和to会交换他们的角色，总之，名为to的suivior区总是空的，一直重复这种的过程，一直到某次GC后to区被填满，会将所有对象移动到老年代区  

*我是一个普通的java对象，我出生在Eden区，在Eden区我还看到和我长的很像的小兄弟，我们在Eden区中玩了挺长时间。有一天Eden区中的人实在是太多了，我就被迫去了Survivor区的“From”区，自从去了Survivor区，我就开始漂了，有时候在Survivor的“From”区，有时候在Survivor的“To”区，居无定所。直到我18岁的时候，爸爸说我成人了，该去社会上闯闯了。于是我就去了年老代那边，年老代里，人很多，并且年龄都挺大的，我在这里也认识了很多人。在年老代里，我生活了20年(每次GC加一岁)，然后被回收。*引自[新生代Eden与两个Survivor区的解释](https://blog.csdn.net/lojze_ly/article/details/49456255)

# jvm性能调优参数

**\-Xss**，对每个线程stack大小进行调整，直接影响到对方法的调用次数  
**\-Xms**, 调整初始堆大小  
**\-Xmx**，调整最大堆的大小
