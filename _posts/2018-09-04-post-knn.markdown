---
layout:     post
title:      "k近邻算法实现"
subtitle:   " \"机器学习\""
date:       2018-09-04 10:00:00
author:     "lang"
header-img: "http://lyang-blog-pics.oss-cn-shanghai.aliyuncs.com/post-bg-2017/0330/170330.jpg"

catalog: true
tags:
    - Tech
---

>k近邻：基于测试集 **T** 和他们的分类 **L** ，给出目标点 **S**，寻找距离目标点最近的 $$k$$ 个点，这$$k$$中占多数的一类就判断为 **S** 的分类

# 模型

当训练集、距离度量、$$k$$值和分类决策树确定后，对于任何一个输入的新实例，它所属的分类可以唯一确定。通过找出距离最近的$$k$$个点，占多数的点的分类即为新实例的分类，当$$k=1$$时，就是 **KNN** （K最近邻）

# 距离度量

通常使用 **欧式距离** ，当然也有其他的距离度量  
假设$$x_i,x_j$$属于$$n$$维的实数向量空间，$$x_i = (x_i^{(1)}, x_i^{(2)},...,x_i^{(n)})^\mathrm{T}, x_j = (x_j^{(1)}, x_j^{(2)},...,x_j^{(n)})^\mathrm{T}$$，那么$$x_i, x_j$$的$$L_p$$距离度量定义为：  
<center>$$L_p(x_i, x_j) = (\sum_{l = 1}^{n}\mid{}x_i^{(l)}-x_j^{(l)}\mid^p)^{\frac{1}{p}}$$</center>  
这里$$p\leq 1$$  

1. 当$$p = 2$$时，称为欧式距离
2. 当$$p = 1$$时，称为曼哈顿距离
3. 当$$p = \infty$$时，它是各坐标距离的最大值，即  
<center>$$L_{\infty}(x_i, x_j) = \mathrm{max}\mid x_i^{(l)} - x_j^{(l)}\mid$$</center>  

# k值的选择

$$k$$值选择 | 优点 | 缺点
较小 | 近似误差减小，只有距离预测点近的训练点起作用 | 估计误差增大，对近邻的训练点敏感
较大 | 减小估计误差 | 增大近似误差，距离较远的也会起作用

* $$k = N$$时，无论输入什么实例，都简单预测为训练实例中最多的类，模型过于简单，忽略了大量有用信息
* 在实际应用中，$$k$$一般取一个较小的值，通过交叉验证来选取最合适的$$k$$值

# kd树构造

k近邻算法最关键的是对训练数据快速搜索k个近邻点，简单的可以通过遍历，计算预测点与每个训练点的距离，当训练集太大就非常耗时  
通过kd树（二叉树）可以将搜索的平均复杂度降到$$O(\log{}N)$$, 构造步骤如下  

对于$$k$$维的训练集$$T = {x_1, x_2,..., x_N}$$  
其中$$x_i = (x_i^{(1)}, x_i^{(2)}, ..., x_i^{(k)}), i = 1, 2, ..., N$$  

1. 构造根节点：选择$$x^{(1)}$$为坐标轴，以训练集$$T$$中的$$x_i^{(1)}的 **中位数** 为切分点，且作为根节点，小于的作为左子树，大于的作为右子树
2. 重复，递归：每次选择切分点的维度跟二叉树的深度相关，$$l=j(\mathrm{mod}k) + 1$$，$$j$$表示当前节点的深度

# kd树搜索

输入：kd树，目标点x  
输出：x的最近邻点  

1. 从根节点出发，比较目标点x与节点在维度$$l=j(\mathrm{mod}k) + 1$$值的大小，小于则继续搜索左子树，大于则搜索右子树，直到找到叶子节点，此时，将此叶子节点作为最近邻点
2. 递归回退，对每个当前节点做以下操作
    1. 比较当前节点与已保存的最近邻点与目标点x的距离，如果当前点距离更近，则更新当前点为最近邻点
    2. 如果当前点为最近邻点，则比较其父节点的另外一个点是否距离目标点更近，如果更近则递归搜索另外一个节点
3. 当递归回退到根节点，搜索结束
   
# 代码

**需要注意，在步骤2.2中，要寻找父节点的另外一个节点，递归获取当前节点的父节点复杂度太高，可以用一个数组保存遍历的路径**

```python
#k近邻算法
import numpy as np
#曼哈顿距离
def distance(x1, x2, p):
    if p < np.inf:
        return np.power(np.sum(np.power(np.abs(x1 - x2), p)), 1/p)
    else:
        return np.max(abs(x1 - x2))

class Node:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None
#构造kd树
def build_kd_tree(data, depth):
    #sorted(data, key = lambda x:x[di])
    if data.size == 0:
        return None
    di = depth % data.shape[1]#维度 = 深度 mod 总维度
    data = data[data[:, di].argsort()]#按维度排序
    mid_index = int(len(data)/2)#中位数
    head = Node(data[mid_index])
    if data.shape[0] == 1:
        return head 
    #递归构造左右子树
    head.left = build_kd_tree(data[0:mid_index], depth+1)
    head.right = build_kd_tree(data[mid_index+1:len(data)], depth+1)
    return head
#前序遍历kd树
def print_tree(head):
    if head == None:
        return None
    print(head.val, end=', ')
    print_tree(head.left)
    print_tree(head.right)

def in_circle(target, source, r):
    distance = np.sqrt(np.sum([i**2 for i in [target - source]]))
    if distance < r:
        return True
    else:
        return False
#搜索kd树
def find_closest(head, depth, node, closest_node, parent_node):
    parent_node.append(head)
    if head == None or (head.left == None and head.right == None):
        return head
    di = depth % data.shape[1]
    
    is_left = True
    #寻找叶子节点，设叶子节点为最近点
    if node.val[di] <= head.val[di]:
        closest_node = find_closest(head.left, depth+1, node,closest_node, parent_node)        
    else:
        is_left = False
        closest_node = find_closest(head.right, depth + 1, node, closest_node, parent_node)
    #比较当前点和叶子，如果当前点距离更近，则当前点为最近点
    if distance(head.val, node.val, 2) < distance(closest_node.val, node.val, 2):
        parent_node.pop()
        closest_node = head
    #如果当前是父节点，返回
    if len(parent_node) == 1:
        return closest_node
    #查找当前点的父节点的另一个子节点是否更近
    r = distance(closest_node.val, node.val, 2)
    parent = parent_node[len(parent_node) - 2]
    if is_left:
        right = parent.right
        r_dis = distance(right.val, closest_node.val, 2)
        if r_dis < r:
            parent_node.pop()
            find_closest(right, depth, node, closest_node, parent_node)
        else:
            return closest_node
    else:
        left = parent.left
        l_dis = distance(left.val, closest_node.val, 2)
        if l_dis < r:
            parent_node.pop()
            find_closest(left, depth, node, closest_node, parent_node)
        else:
            parent_node.pop()
            return closest_node

    
#x1, x2, x3 = np.array([2, 3]), np.array([5, 4]), np.array([9, 6], np.array([4, 7], np.array([8, 1], np.array([7, 2])
data = np.array([[2, 3], [5, 4], [9, 6], [4, 7], [8, 1], [7, 2]])
head = build_kd_tree(data, 0)
node = Node([4, 6])
parent_node = []
closest_node = Node(float('inf'))
closest_node = find_closest(head, 0, node, closest_node, parent_node)

#print_tree(head.val)
import matplotlib.pyplot as plt
x = []
y = []
for d in data:
    x.append(d[0])
    y.append(d[1])
    
t_x = node.val[0]
t_y = node.val[1]

n_x = closest_node.val[0]
n_y = closest_node.val[1]

plt.scatter(x, y)
plt.scatter(t_x, t_y, color='red')
plt.scatter(n_x, n_y, color='green')
plt.show()
print(closest_node)
```

效果图：
![输出][pic]
[pic]:data:image/png;base64,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EiMAQCoxAgCkEiMAQCoxAgCkEiMAQCoxAgCkEiMAQCoxAgCkEiMAQCoxAgCkEiMAQCoxAgCkEiMAQCoxAgCkEiMAQCoxAgCkEiMAQCoxAgCkEiMAQCoxAgCkEiMAQCoxAgCkEiMAQCoxAgCkEiMAQCoxAgCkEiMAQCoxAgCkEiMAQCoxAgCkEiMAQCoxAgCkEiMAQCoxAgCkEiMAQCoxAgCkEiN7YOu27eXltZvLwjc3VF9jGQDoDDGyG8+u/LDMmL+k9M17eseI5VgPAIxco2JkwYIF5ZRTTimHHHJINWbMmFEWLVpUP7p7nd6ZCI5pQyKkNWJdDEECACPXqBh58sknyzPPPFNWr15djdtuu61MmDChvPXWW/UWu9bJnYlLMe1nRIaOiJF43CUbABiZRsXIcA499NBy33331UvfNDg4WD3x1hgYGOjYzsTckOEipH3EdgDAdxfH7UbGyNatW8sjjzxS9t1337Jq1ap67Tf19/dXT759dGJnYrLqcPHRPmI7AOC7a1yMrFixohx00EFl/PjxZeLEidVlm2/jzAgAjH1x3G5UjGzZsqWsWbOmvPbaa+WWW24pRxxxxLeeGWnXyZ1pzRkZbgJrDHNGAKAzGhcj7c4666xy9dVX10u71umdad1N0x4krXXupgGAkWt8jJx55pllzpw59dKujcbORHC031UTy0IEADqjUTFy6623lpdeeqm899571dyRuLV33Lhx5fnnn6+32LXR2JkQl2Jiboi/wAoAndeoGLnyyitLX19fdQfNpEmTqks0exoiYbRiBAAYPY2KkZESIwAw9ogRACCVGAEAUokRACCVGAEAUokRACCVGAEAUokRACCVGAEAUokRACCVGAEAUokRACCVGAEAUokRACCVGAEAUokRACCVGAEAUokRACCVGAEAUokRACCVGAEAUokRACCVGAEAUokRACCVGAEAUokRACCVGAEAUokRACCVGAEAUokRACCVGAEAUokRACCVGAEAUokRACCVGAEAUokRACCVGAEAUokRACCVGAEAUokRACCVGAEAUokRACCVGAEAUokRAHZp67bt5eW1m8vCNzdUX2MZOkmMAPCtnl35YZkxf0npm/f0jhHLsR46pVExMn/+/HL66aeXgw8+uEyaNKlccMEF5e23364f3T0xAtA5ERzThkRIa8S6GIKETmlUjJx77rnl/vvvL2+99VZZvnx5Oe+888rUqVPLZ599Vm+xa2IEoDPiUkz7GZGhI2IkHnfJhk5oVIy027RpU/XkXnzxxXrNNw0ODlZPvDUGBgbECEAHxNyQ4SKkfcR2MFJx3G5sjKxZs6Z6citXrqzXfFN/f3/1ePsQIwAjE5NVh4uP9hHbwUg1Nka2b99ezj///DJz5sx6zc6cGQEYHc6M8H2K43YjY+S6664rfX19VWDsqdHYGYBe1JozMtwE1hjmjNBJjYyRG264oRx77LFl3bp19Zo9I0YAOqd1N017kLTWuZuGTmlUjMSlmeuvv75MmTKlvPPOO/XaPSdGADorgqP9rppYFiJ0UqNi5Nprry0TJ04sL7zwQtm4ceOO8fnnn9db7JoYAei8uBQTc0P8BVZGS6NiJJ7IcCP+9sieECMAMPY0KkZGSowAwNgjRgCAVGIEAEglRgCAVGIEAEglRgCAVGIEAEglRgCAVGIEAEglRgCAVGIEAEglRgCAVGIEAEglRgCAVGIEAEglRgCAVGIEAEglRgCAVGIEAEglRgCAVGIEAEglRgCAVGIEAEglRgCAVGIEAEglRgCAVGIEAEglRgCAVGIEAEglRgCAVGIEAEglRgCAVGIEAEglRgCAVGIEAEglRgCAVGIEAEglRgCAVGIEAEglRgCAVGIEAEglRgCAVGIEAEglRgBgN7Zu215eXru5LHxzQ/U1lukcMQIAu/Dsyg/LjPlLSt+8p3eMWI71dEajYuTFF18ss2fPLpMnT66e1BNPPFE/smfECACdFMExbUiEtEasiyFIOqNRMbJo0aJy++23l8cff1yMAJAqLsW0nxEZOiJG4nGXbEauUTEy1J7EyODgYPXEW2NgYECMANARMTdkuAhpH7EdIxPH7TEbI/39/dV27UOMADBSMVl1uPhoH7EdIzOmY8SZEQBGizMj3584bo/ZGGk3GjsDQG9qzRkZbgJrDHNGOkeMAMC3aN1N0x4krXXupukMMQIAuxDB0X5XTSwLkc5pVIx8+umn5c0336xGPKk//vGP1ff/+te/6i12TYwAMBriUkzMDfEXWEdHo2Jk6dKl1ZNpH3PmzKm32DUxAgBjT6NiZKTECACMPWIEAEglRgCAVGIEAEglRgCAVGIEAEglRgCAVGIEAEglRgCAVGIEAEjVVTHy8ccfVzszMDBQ7ZBhGIZhGM0fcdyO43ccxzslLUZaO2MYhmEYxtgbcRzvlLQY2bZtW7UjUVbDlddIRit04utwj3f76PX9j+E1YP/tv/cAr4HR2f84bsd/N47jnZIWI6Mp/rHihxBfe1Gv73/wGrD/9t97gNfA2Nl/MdKFen3/g9eA/bf/3gO8BsbO/ouRLtTr+x+8Buy//fce4DUwdva/K2NkcHCw9Pf3V197Ua/vf/AasP/233uA18DY2f+ujBEAYOwQIwBAKjECAKQSIwBAKjECAKTqqhiZP39+Of3008vBBx9cJk2aVC644ILy9ttv1492vwULFpRTTjmlHHLIIdWYMWNGWbRoUf1o74nXQ9zaNnfu3HpNd4uZ87G/Q8dRRx1VP9o7NmzYUC699NJy2GGHlQMOOKBMnz69vP766/Wj3a2vr2+n10CM6667rt6iu3355Zfl9ttvL9OmTSv7779/+dGPflTuuOOOjv6l0LHgk08+qd73pk6dWv07nHHGGWXZsmX1o83UVTFy7rnnlvvvv7+89dZbZfny5eW8886rfhifffZZvUV3e/LJJ8szzzxTVq9eXY3bbrutTJgwofr36DXxixdvSKeeempPxchJJ51UNm7cuGNs2rSpfrQ3fPTRR9UB+Yorriivvvpqee+998qSJUvK2rVr6y26W/y8h/78Fy9eXMXI0qVL6y262+9///ty+OGHl6effrr62f/973+vPpz+6U9/qrfoDb/+9a/Lz372s/Liiy+WNWvWVO8NP/jBD6pQb6quvkwTv5jxixg/kF516KGHlvvuu69e6g2ffvppOf7446s34lmzZvVUjMRZgF42b968MnPmzHqJeO0fd9xxZfv27fWa7hYfQK+88sp66WsXXnhhueyyy+ql7vf555+X8ePHV0E2VLw3xFmjpurqGIkijBhZuXJlvaZ3bN26tTzyyCNl3333LatWrarX9obLL7+83HTTTdX3vRYjBx54YJk8eXJ1Vujiiy8u7777bv1obzjxxBOrn/1FF11UXao97bTTyr333ls/2lu2bNlSnSW488476zXd7w9/+EN1ZizODIc4Q37kkUeWhx9+uFruBXGJJo57cUZwqLhsH++HTdW1MRKfBM4///ye+5S0YsWKctBBB1VlPHHixOqyTS+JAItLFV988UW13EsxEvODHnvsseo10DorFHNGNm/eXG/R/fbbb79q3HrrreWNN94o99xzT3XN/IEHHqi36B2PPvpo9T7wwQcf1Gu6X7zv33LLLWXvvfcu++yzT/U15o71mpgjEr//8bOPD6Z/+9vfqn+Ln/zkJ/UWzdO1MRITtqKQ439z3Evi01CcEXrttdeqX8ojjjiiZ86MvP/++9WnoPg01NJLMdIu5kpFjNx11131mu4Xc6TijXioG2+8sfpU2GvOOeecMnv27HqpN8SHkWOPPbb6GlH+17/+tZrI/Je//KXeojfEHKlf/vKX1RmSCNKf//zn1aTuOHPYVF0ZIzfccEP1gly3bl29pnedddZZ5eqrr66XutsTTzyx45evNWI5PhHE9/EJodecffbZ5ZprrqmXul9MWL/qqqvqpa/FXWZTpkypl3rD+vXry7hx48rChQvrNb0h3vfvvvvueulrv/vd78pPf/rTeqm3xAeSDz/8sPo+JrX+6le/qr5voq6KkThFd/3111dvPO+88069tredeeaZZc6cOfVSd4trpTE/aOiIW71j8lovzhuK/0HWMcccU93a2CsuueSSnS7NxhyS9rMl3S7mDx199NHVra69JM6CRHwOFZdpYkJ7L4u7zOKy/Z///Od6TfN0VYxce+211T/4Cy+88I3b22J2cS+I6+QvvfRSdUtbnKKMW3vj09Hzzz9fb9F7eukyzc0331y99uOM4CuvvFKdoo+/NxOfkntF3NIdcwVi0mZcrnzooYeqSb0PPvhgvUX3i7+pEWeI4s6iXhMfvCLAW7f2/uMf/6guVf/mN7+pt+gN//znP8uzzz5bvRfE+3/cSfOLX/yi/Oc//6m3aJ6uipE4JT/ciL890gvilraYJxN30MSdBHGJppdDJPRSjMTdM3EnTcybiLODcUtjr91JFZ566qly8sknVxNZTzjhhJ67m+a5556r3vdad5T0kvY/9vXjH/+4up015tL1kpi8HPsex4I4QxZXDD7++OP60Wbq2gmsAMDYIEYAgFRiBABIJUYAgFRiBABIJUYAgFRiBABIJUYAgFRiBABIJUYAgFRiBABIJUYAgFRiBABIJUYAgFRiBABIJUYAgFRiBABIVMr/A+YdYbqm/WVOAAAAAElFTkSuQmCC