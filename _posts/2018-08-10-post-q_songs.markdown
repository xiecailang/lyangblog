---
layout:     post
title:      "小Q的歌单"
subtitle:   " \"笔试真题\""
date:       2018-08-10 10:00:00
author:     "lang"
header-img: "http://lyang-blog-pics.oss-cn-shanghai.aliyuncs.com/post-bg-2017/0330/170330.jpg"

catalog: true
tags:
    - Tech
---

# 问题

小Q有X首长度为A的不同的歌和Y首长度为B的不同的歌，现在小Q想用这些歌组成一个总长度正好为K的歌单，每首歌最多只能在歌单中出现一次，在不考虑歌单内歌曲的先后顺序的情况下，请问有多少种组成歌单的方法。  
每个输入包含一个测试用例  

* 每个测试的第一行包含一个整数，表示歌单的总长度K（1<=K<=1000）.  
* 接下来的一行包含四个正整数，分别表示歌的第一种长度A（A<=10）和数量X（X<=100）以及歌的第二种长度B（B<=10）和数 量Y（Y<=100）.保证A不等于B。  

输出描述：  

* 输出一个整数，表示组成歌单的方法取模。因为答案可能会很大，输出对1000000007取模的结果

输入示例：  
    5
    2 3 3 3
输出示例：  
    9

# 思路

排列组合问题，问题的关键在于求$$C(n, m)$$的值，利用杨辉三角和数学归纳  
$$C(n, m) = C(n - 1, m - 1) + C(n - 1, m)$$  
要得到长度为K的歌单，则需要从X中拿取i首歌，剩下的从Y中拿取，判断条件如下  

1. i\*A <= K, 从X中选择的歌单长度不能超过总长K
2. (K-i\*A)\%B == 0, 剩下的歌曲从Y中挑选，且总长刚好为K
3. (K - i\*A)/b <= Y, 在Y中挑选的歌曲数量不能超过Y

满足以上条件，**组成歌单的方法=C(x, i)\*C(y, (k - i\*a)/b)**

# 代码

```python
#小q的歌单
k = 5
a,x,b,y = 2,3,3,3
c= [([0] * 105) for i in range(105)]
c[0][0] = 1
mod_ = 1000000007
for i in range(1,101,1):
    c[i][0] = 1
    for j in range(1,101,1):
        c[i][j] =(c[i - 1][j - 1]+c[i - 1][j])
ans = 0
for i in range(x):
    if i*a <= k and (k - a*i)%b ==0 and int((k - a*i)/b) <= y:
        ans += c[x][i]*c[y][int((k - a*i)/b)] 
print(ans%mod_)
```

**Note**  
代码中需要注意的一点是python给二位数组赋值方法，不能用[[0]\*105]\*105,这种方法每行都是同一个引用